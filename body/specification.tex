\chapter{Description of Work}

%Explaining what your project is meant to achieve, how it is meant to function, perhaps even a functional specification.
\section{Requirements Specification}
The proposed solution to the problem described is to build a client application that incorporates the features of modern messaging clients which makes them so appealing, whilst using email as the underlying transport mechanism to take advantage of its distributed and federated architecture. Below is an outline of the functional and non-functional requirements that will be used to guide the design and implementation of this system. The requirements as defined below will be used as the basis for validation through User Acceptance Testing as the project progresses.

\subsection{Functional Requirements}\label{sec:functional-requirements}
\renewcommand{\labelenumii}{\theenumii}
\renewcommand{\theenumii}{\theenumi.\arabic{enumii}.}
\begin{enumerate}
  \item Login
  \begin{enumerate}
    \item The application allows users to log in using any email account with IMAP \& SMTP support.
    \item The application remembers login credentials after the first login.
  \end{enumerate}

  \item Start Conversations
  \begin{enumerate}
    \item The application allows users to start a new conversation.
    \item The application allows users to add an unlimited number of people to the new conversation, using their email address.
    \item The application allows users to set a name for each person that they add to the conversation.
    \item The application allows users to set a name for the conversation.
  \end{enumerate}

  \item Send Messages
  \begin{enumerate}
    \item The application allows users to send text messages in a conversation.
    \item The application allows users to send messages containing unicode characters, including emoji.
    \item The application allows users to send images and other file attachments.
    \item The application shows a `sending' indicator until the message has actually been sent.
    \item The application allows users to `tag' other participants in messages.
  \end{enumerate}

  \item Receive Messages
  \begin{enumerate}
    \item The application presents an operating-system-level notification when a message is received if the application is not currently in focus.
    \item The application highlights conversations with unread messages, removing this highlight once the conversation has been opened.
    \item The application retrieves any messages received while the app was not running when it is reopened.
  \end{enumerate}
  
  \item View Conversations
  \begin{enumerate}
    \item The application displays a list of all conversations that a user is part of.
    \item The application lists conversations ordered by the time that a message was last received within each conversation.
    \item The application displays messages for a specific conversation if it is selected by the user.
    \item The application allows users to read messages received in all conversations.
    \item The application allows users to view message attachments received in all conversations.
    \item The application displays messages within a conversation in the order in which they were sent.
    \item The application displays the name of the user that sent each message.
    \item The application displays the time that a message in the conversation was sent.
    \item The application allows users to change the name of an existing conversation.
    \item The application allows users to add new participants to an existing conversation using their email address.
  \end{enumerate}

  \item Message Replies
  \begin{enumerate}
    \item The application allows messages to be replied to directly by the user.
    \item The application shows replies to a message as a thread attached to the message.
    \item The application only allows top-level messages to be replied to. Replies cannot have their own reply thread.
    \item The application does not mark a conversation as having unread messages if only replies are unread in the conversation.
  \end{enumerate}
\end{enumerate}

\subsection{Non-Functional Requirements}
\begin{enumerate}
  \item The application is cross-platform; compatible with Windows, MacOS, and Linux operating systems.
  \item The application is quick and simple to set up.
  \item The application ensures that messages sent between participants are end-to-end encrypted using suitable cryptographic techniques.
  \item The application performs well, with minimal perceived loading times and is quick to responsd to user interaction.
  \item The application has a user interface that is attractive, consistent, and intuitive to navigate and use.
\end{enumerate}

\section{Development Methodology}\label{sec:development-methodology}

This project will use an Agile \cite{fowler2001agile} development methodology, to allow for flexibility in response to any unforeseen obstacles that may occur, in such a way as to minimise risk to the success of the project as a whole. In particular, the Kanban \cite{anderson2010kanban} method of project management will be utilised, along with elements of the Extreme Programming (XP) methodology \cite{beck2000extreme}. In line with the Agile Manifesto, which states that working software is the primary measure of progress \cite{fowler2001agile}, continuous delivery of working software will begin as early as possible, with additional features being added to a minimum-viable-product incrementally.

This will be achieved through limited `Big Design Up Front' as would be the case with a Waterfall development model \cite{balaji2012waterfall}. Instead, incremental design will be favoured, since this allows for design decisions to reflect the problems encountered at different stages of development, that may not be foreseen up front without prototyping and research, thus allowing the project plan to adapt to changing circumstances.

The benefit of the Kanban methodology in particular is that any card can be taken from the project backlog at any time and placed on the Kanban board, removing the rigidity that can be enforced by fixed-length sprints in other Agile frameworks such as Scrum. This is ideal for this project, as the future direction will likely be dictated by research undertaken as the project progresses, such as research into the use of email protocols.

The XP concept of Test-Driven Development will be used throughout the project, as a means of ensuring that the code written meets requirements, and to ensure that any problems are found as early in the development cycle as possible, to minimise effort required in fixing them. Unit tests will be written alongside the code that they are designed to test, and a Continuous Integration (CI) pipeline will be used to ensure that all tests are passed before feature branches can be merged into the master branch. This form of regression testing ensures that new feature code does not cause breaking changes for existing code which is vital in ensuring that the software is of the highest possible quality.