\chapter{Design}

% Containing a comprehensive description of the design chosen, how it addresses the problem, and why it is designed the way it is.
Although significant amounts of up-front design has been avoided, there are some design decisions that have been researched and made in advance, to underpin the development process. These key design decisions surrounding system architecture, the message threading model, and user interface design are outlined below.

\section{System Architecture}

Architectural design decisions for this project have been heavily influenced by the requirement that the entire system should be federated, not relying on services from any individual provider. A number of possible architectural models were proposed as a result of research and these possibilities are outlined below.

\begin{enumerate}
  \item \label{itm:web-cloud} A web based system, hosted on a cloud service provider such as Amazon Web Services (AWS), Google Cloud Platform (GCP) or Microsoft Azure.
  \item \label{itm:on-demand-cloud} A locally installed application which spins up a compute instance on a cloud service provider on demand for each user for handling computationally expensive work.
  \item \label{itm:local-service} A locally running web-based user interface which communicates over HTTP with a separate locally running service process.
  \item \label{itm:electron} An Electron application which encapsulates the frontend user interface and backend service into a single executable that can be run locally.
\end{enumerate}

Each of the models listed above present their own advantages and disadvantages. Although \ref{itm:web-cloud} would mean that the software is accessible from anywhere, by any device with a web browser, it also means that users have no choice but to trust the backend of this software, running in the cloud, with their data, which means that the federated aspect of the system is lost.

In \ref{itm:on-demand-cloud}, users would have more control over their data in the cloud, as they are responsible for managing the compute instance, however implementing this model would mean that users are required to have in-depth knowledge of AWS or similar, which detracts from the usability of the system.

The model proposed in \ref{itm:local-service} does not rely on any remotely hosted software, and so maintains the integrity of the federated system. Furthermore, by keeping the service as a separate entity, it would be relatively simple to access it from other devices, for example a mobile phone on the same network as the host PC, using a consistent API. However, by requiring users to manually start the user interface, navigate to it in the browser, and then start the service, it increases the barrier to entry for less technical users.

The Electron application proposed in \ref{itm:electron} will be easy for users to set up and run since it will consist of running a single executable, and it allows for web technologies to be used to build a desktop application meaning that UI development will be fast. A disadvantage of using this model is that the application will only be available on desktop devices.

It is clear that the final solution will require compromises, and that any architecture will have flaws. It was decided that the most important requirements that the system architecture should fulfill are ease of use, to ensure that the software is accessible to as many users as possible, and that the system should be entirely federated. Therefore, the most suitable architectural model, and the one to be used in this project is \ref{itm:electron}, despite the fact that this limits the platform to desktops only.

\section{Message Threading Model}\label{sec:message-threading-model}
An important design aspect of this project is deciding on a suitable message threading model to maximise functionality and usability. Indeed, one of the motivations for completing this project is that email as used in its present form does not handle complex threaded conversations well. The need for message threading stems from the requirement that users are able to directly reply to messages. In designing this system, it was noted that current messaging software products use various different models for message threading, and that the possible models must be evaluated in order to ascertain the most appropriate for this project.

There is a considerable amount of previous work on how best to handle message threading, particularly within the scope of email. Lewis \& Knowles stated that: ``While user clients typically insert in messages structural information useful for recovering threads, inconsistencies between clients, loose standards, creative user behavior, and the subjective nature of conversation make threading systems based on structural information only partially successful.'' \cite{lewis1997threading}. This project aims to avoid the issues of client inconsistencies and loose standards by providing a specialised client application and well-defined data schema to be sent using email as a transport mechanism.

It is important to realise that one message can have multiple replies, each initiating a separate message thread. For this reason, message threads are best modeled using a tree structure \cite{palme1998message}. In email, there does not exist an explicit reference from a message to its replies, so the relationship can be described as unidirectional from reply to parent. Some email clients provide a feature to generate these reverse links, which are useful to allow a user to see if replies already exist before composing their own \cite{palme1998message}, though this functionality is by no means universal. Outside of email, there is a mix of bidirectional and unidirectional relationships between replies and their parents.

In order to pick a threading system for this project, a review of several popular existing social messaging applications was conducted, highlighting the advantages and disadvantages of their threading models. The results of this research are summarised below.

\begin{itemize}
  \item Slack Model
    \begin{itemize}
      \item A message provides links to its replies.
      \item Only one level of replies is allowed. Replies cannot be replied to.
      \item Replies can only be accessed via their parent message.
    \end{itemize}
  \item Twitter Model
    \begin{itemize}
      \item Replies can be traced back to the parent from any level, and parent has links to all direct and indirect replies.
      \item Replies can be replied to up to an infinite depth.
    \end{itemize}
  \item Facebook Messenger Model
    \begin{itemize}
      \item Replies can be traced back to the parent from any depth, but a parent message does not provide any links to its replies.
      \item Replies can be replied to up to an infinite depth.
    \end{itemize}
\end{itemize}

It is interesting to note that during development, the message threading model used by Slack went through many different iterations involving both conceptual structure and user interface design \cite{florin2018}. This research at Slack found that when users were allowed to reply to replies, threads quickly became very complex and difficult for users to understand, leading to the approach currently implemented in Slack where each thread is restricted to one level of replies \cite{florin2018}.

The final design decision is a tradeoff between functionality and usability. Whilst allowing greater depth of replies provides users with more flexibility in the way that they construct conversations, it also detracts from usability, with it becoming more difficult for users to follow the discussions that they are interested in. It is proposed that this project will initially implement a threading structure similar to that of Slack, with replies limited to one level deep, though a top level message can have an unlimited number of sequential replies at this depth. Following this implementation, User Testing will be conducted to ascertain whether this model allows enough flexibility for users to hold discussions, whilst being easy to use. If the results of this testing indicate a need for more complex threading then the design will be revisited.

\subsection{Message Schema}
In designing the schema for the messages to be send via email in this application, there were a number of factors to be taken into consideration. These included minimising the amount of data that would need to be sent in each message, and ensuring that messages can be queried quickly and effectively to minimise search times for the user. The schema must be able to handle the threading model proposed in Section \ref{sec:message-threading-model}, and has been designed with all aspects of this in mind. details on the implementation-specific details of these message schemas can be found in section .

The final solution uses the following message schemas:

\subsubsection{Message}
\begin{verbatim}
subject: EMAILSOCIALMESSAGING:{conversationId}
body:    {
           messageId,
           conversationId,
           parentId,
           timestamp,
           senderId,
           content,
           participants,
           conversationName
         }
\end{verbatim}

\subsubsection{Public Key Request}
\begin{verbatim}
subject: EMAILSOCIALMESSAGING-KEX
body:    {
           conversationId,
           senderEmail,
           participants
         }
\end{verbatim}

\subsubsection{Public Key Response}
\begin{verbatim}
subject: EMAILSOCIALMESSAGING-KEY
body:    {
           conversationId,
           senderEmail,
           key
         }
\end{verbatim}

\subsubsection{Conversation Key Response}
\begin{verbatim}
subject: EMAILSOCIALMESSAGING-CONKEY
body:    {
           conversationId,
           encryptedKey
         }
\end{verbatim}

\section{User Interface}

An important element of this project is to create a simple and intuitive user interface, so that it can be used without a need for extensive instruction and training. Based on an analysis of the functional requirements outlined in Section \ref{sec:functional-requirements}, elements of the user interface that are considered as essential for meeting the requirements are as follows:
\begin{itemize}
  \item Ability to enter account credentials
  \item `New Conversation' button
  \item List of conversations
  \item Ability to view messages and replies
  \item Sender Indicators
  \item Composer
  \item `Add Attachment' button
\end{itemize}

\begin{figure}[h!]
  \centering
  \fbox{ 
    \includegraphics[width=\textwidth]{images/wireframes.jpg}
  }
  \caption{Low-fidelity wireframe showing the key user interface elements}
  \label{fig:ui-wireframes}
\end{figure}

Using these essential UI elements some low-fidelity wireframes were produced, seen in Figure \ref{fig:ui-wireframes}. The wireframes have deliberately been created at a high-level, without large amounts of detail, to allow for changes as the project progresses through the Agile development process. These wireframes will be used to support building a user interface using React, however it is noted that the specifics of the design will likely change over time as the project evolves and user feedback is gathered. The designs should, however, allow for the development of a Minimum Viable Product.
